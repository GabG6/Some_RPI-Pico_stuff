#include "stdio.h"
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/irq.h"
// the .pio.h file also defines (in this order): D0 (8 bits), A0 (8 bits), RW, WR, DIR, OE
#include "Z80.pio.h"

// PIO and state machine
PIO pio;
uint sm_rd;
uint sm_wr;
uint offset_rd;
uint offset_wr;

bool irq_rd_flag = false;
bool irq_wr_flag = false;

// a counter to simulate the data in memory (or after some calculations)
uint16_t counter = 0;
// the received data from pio is a combination of the data and the address
uint32_t addr_data;
// the data part
uint8_t data;
// the address part
uint16_t address;
// used for checking whether the sm has returned to the default state
uint8_t current_pc;

// handle the IRQs that are generated by the sm_rd and sm_wr
static void pio_irq_handler()
{
    // check which IRQ was raised:
    if (pio0_hw->irq & 1)
    {
        // *********************************************
        // read:
        // the pio receives an address, sets this irq
        // the c code determines a data value
        // the pio sets this data value on the data bus (and restores the default situation)
        // *********************************************

        // set the read flag to true (handled in main-while-loop)
        irq_rd_flag = true;
        // get the address (and data) from the sm
        addr_data = pio_sm_get(pio, sm_rd);
        // the lowest 8 bits are the data and the next 8 bits are the address
        data = addr_data & 0xFF;
        address = addr_data >> 8;

        // determine the value to be send back
        counter++;
        if (counter == 256)
            counter = 0;

        // send the data to the pio for writing it to the data bits
        pio_sm_put(pio, sm_rd, counter);
        // clear the irq flag: set bit for irq 1 signaling it to be cleared
        pio0_hw->irq |= 1 << 0; 
    }

    if (pio0_hw->irq & 2)
    {
        // *********************************************
        // write:
        // the pio receives an address and the data
        // the c code does something useful with them
        // the pio restores the default situation
        // *********************************************

        // set the write flag to true (handled in main-while-loop)
        irq_wr_flag = true;
        // get the address and data from the sm
        addr_data = pio_sm_get(pio, sm_wr);
        // the lowest 8 bits are the data and the next 8 bits are the address
        data = addr_data & 0xFF;
        address = addr_data >> 8;

        // do something useful with the data and address

        // clear the irq flag: set bit for irq 2 signaling it to be cleared
        pio0_hw->irq |= 1 << 1; 
    }
}

// Configure the pio state machine
void configure_pio_sm()
{
    // pio 0 is used
    pio = pio0;
    // state machine 0 is used.
    sm_rd = 0;
    sm_wr = 1;

    // load the sm_rd program into the pio memory
    offset_rd = pio_add_program(pio, &Z80_read_program);
    // load the sm program into the pio memory
    offset_wr = pio_add_program(pio, &Z80_write_program);
    // make a sm_rd config
    pio_sm_config smc_rd = Z80_read_program_get_default_config(offset_rd);
    // make a sm_wr config
    pio_sm_config smc_wr = Z80_write_program_get_default_config(offset_wr);

    // function select: this allows pio to set output on a gpio
    for (int i = D0; i <= OE; i++)
        pio_gpio_init(pio, i);

    // TODO: for testing purposes, set data and address lines to 0 via pull down, normally this would be set externally
    for (int i = D0; i < RD; i++)
        gpio_set_pulls(i, false, true);

    // set initial pindirs: D0 - D7 are (also) output
    pio_sm_set_consecutive_pindirs(pio, sm_rd, D0, 8, true);
    pio_sm_set_consecutive_pindirs(pio, sm_wr, D0, 8, true);
    // set initial pindirs: A0 - A7 are input
    pio_sm_set_consecutive_pindirs(pio, sm_rd, A0, 8, false);
    pio_sm_set_consecutive_pindirs(pio, sm_wr, A0, 8, false);
    // set initial pindirs: RD, WR are input
    pio_sm_set_consecutive_pindirs(pio, sm_rd, RD, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm_wr, RD, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm_rd, WR, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm_wr, WR, 1, false);
    // set initial pindirs: DIR and OE are output
    pio_sm_set_consecutive_pindirs(pio, sm_rd, DIR, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm_wr, DIR, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm_rd, OE, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm_wr, OE, 1, true);

    // pio 'in' pins: inputs start at the first data bit (D0)
    sm_config_set_in_pins(&smc_rd, D0);
    // pio 'out' pins: data D0-D7 can also be output
    sm_config_set_out_pins(&smc_rd, D0, 8);
    // pio 'set' pins: DIR (LSB) and OE (MSB)
    sm_config_set_set_pins(&smc_rd, DIR, 2);
    // Reading from RxFIFO: Shift to left, autopull disabled
    sm_config_set_in_shift(&smc_rd, false, false, 32);
    // Writing to TxFIFO: Shift to right, autopull disabled
    sm_config_set_out_shift(&smc_rd, true, false, 32);
    // pio 'in' pins: inputs start at the first data bit (D0)
    sm_config_set_in_pins(&smc_wr, D0);
    // pio 'out' pins: data D0-D7 can also be output
    sm_config_set_out_pins(&smc_wr, D0, 8);
    // pio 'set' pins: DIR (LSB) and OE (MSB)
    sm_config_set_set_pins(&smc_wr, DIR, 2);

    // set the jmp pin
    sm_config_set_jmp_pin(&smc_rd, RD);
    sm_config_set_jmp_pin(&smc_wr, WR);

    // Reading from RxFIFO: Shift to left, autopull disabled
    sm_config_set_in_shift(&smc_wr, false, false, 32);
    // Writing to TxFIFO: Shift to right, autopull disabled
    sm_config_set_out_shift(&smc_wr, true, false, 32);
    // set clock to 4Mhz as that is - I think - the speed of the bus for the Z80
    // clkdiv = 125MHz/4MHz = 31.25 => 31+64/256, thus the frac fits nicely
    // TODO: slowest for testing, at 4MHz the bouncing of manually setting RD and WR to 0 with a Dupont wire causes many iteration.
    sm_config_set_clkdiv(&smc_rd, 0);
    sm_config_set_clkdiv(&smc_wr, 0);
    // sm_config_set_clkdiv(&smc_rd, 31.25);
    // sm_config_set_clkdiv(&smc_wr, 31.25);
    // init the pio sm with the config
    pio_sm_init(pio, sm_rd, offset_rd, &smc_rd);
    pio_sm_init(pio, sm_wr, offset_wr, &smc_wr);
    // enable the sm
    pio_sm_set_enabled(pio, sm_rd, true);
    pio_sm_set_enabled(pio, sm_wr, true);

    // set the IRQ handler
    irq_set_exclusive_handler(PIO0_IRQ_0, pio_irq_handler);
    // enable the IRQ
    irq_set_enabled(PIO0_IRQ_0, true);
    // allow irqs from the low 2 state machines
    pio0_hw->inte0 = PIO_IRQ0_INTE_SM0_BITS | PIO_IRQ0_INTE_SM1_BITS;
}

int main()
{
    // needed for printf
    stdio_init_all();

    // initialize the state machines
    configure_pio_sm();

    // print the gpio assignments
    printf("D0=%d\n", D0);
    printf("A0=%d\n", A0);
    printf("RD=%d\n", RD);
    printf("WR=%d\n", WR);
    printf("DIR=%d\n", DIR);
    printf("OE=%d\n", OE);

    while (1)
    {
        tight_loop_contents();

        if (irq_rd_flag)
        {
            // a read has been observed by the sm_rd

            // clear the flag
            irq_rd_flag = false;
            // print the values received from the sm
            printf("read_data: raw=%zu address=%d data=%d sent back=%d\n", addr_data, address, data, counter);
        }

        if (irq_wr_flag)
        {
            // a write has been observed by the sm_wr

            // clear the flag
            irq_wr_flag = false;
            printf("write_data: raw=%zu address=%d data=%d\n", addr_data, address, data);
        }
    }
}